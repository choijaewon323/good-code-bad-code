# 7.1 불변 객체로 만드는 것을 고려하라


- 가변 객체의 문제
  - 추론하기 어렵다
  - 멀티스레드 문제가 발생할 수 있다
- 기본적으로는 불변, 필요한 곳에만 가변적으로 만들것

## 7.1.1 가변 클래스는 오용하기 쉽다

- 세터 함수 - 가변적으로 만드는 가장 일반적 방법

```java

class UserDisplay {
    private final MessageBox messageBox;

    void sayHello() {
        TextOptions defaultStyle = new TextOptions(Font.ARIAL, 12.0);

        messageBox.renderTitle("Important message", defaultStyle);
        messageBox.renderMessage("Hello", defaultStyle);
    }
}

class MessageBox {
    private final TextField titleField;
    private final TextField messageField;

    void renderTitle(String title, TextOptions baseStyle) {
        baseStyle.setFontSize(18.0);
        titleField.display(title, baseStyle);
    }

    void renderMessage(String message, TextOptions style) {
        messageField.display(message, style);
    }
}

```

- 가변 객체의 문제가 발생할 여지가 있따.

## 7.1.2 해결책: 객체를 생성할 때만 값을 할당하라

```java

class TextOptions {
    private final Font font;
    private final Double fontSize;

    TextOptions(Font font, Double fontSize) {
        this.font = font;
        this.fontSize = fontSize;
    }

    // getter
}

```

- 불변으로 바뀐 TextOptions 객체
- 만약 글꼴 크기만 재정의할 수 있어야 한다면? 쓰기 시 복사 (copy on write) 패턴 사용

```java

class MessageBox {
    private final TextField textField;

    void renderTitle(String title, TextOptions baseStyle) {
        titleField.display(
            title,
            baseStyle.withFontSize(18.0)
        );
    }
}

```

## 7.1.3 해결책: 불변성에 대한 디자인 패턴을 사용하라

- 모든 필드가 불변적이라면 버그는 방지할 수 있으나 클래스가 쓸모없어질 수 있다
- 반드시 필요하지 않는 필드가 있거나 가변 필드가 필요한 경우, 빌더 패턴과 쓰기 시 복사 패턴 사용 가능

빌더 패턴
- 세터보다는 빌더가 낫다

```java

class TextOptionsBuilder {
    private final Font font;
    private Double? fontSize;

    TextOptionsBuilder(Font font) { // 필수값은 생성자로 받음
        this.font = font
    }

    TextOptionsBuilder setFontSize(Double fontSize) { // 필수적이지 않은 값은 빌더의 세터로 받음
        this.fontSize = fontSize;
        return this;
    }

    TextOptions build() {
        return new TextOptions(font, fontSize);
    }
}

```

- 만약 생성 후 필드를 약간 수정해야하는 경우라면? 빌더 패턴도 가능하긴 하지만 약간 번거로움 -> 쓰기 시 복사 패턴

쓰기 시 복사 패턴

```java

class TextOptions {
    ...

    TextOptions withFont(Font newFont) {
        return new TextOptions(newFont, fontSize);
    }

    TextOptions withFontSize(Double newFontSize) {
        return new TextOptions(font, newFontSize);
    }
}

```

- 원본 객체의 수정 없이 필드를 수정할 수 있다