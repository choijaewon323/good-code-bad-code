# 7.6 논리에 대한 진실의 원천을 하나만 가져야 한다

- 진실의 원천 : 데이터 뿐만 아니라 논리에도 적용되어야함
- 코드의 한 부분에서 수행되는 일이 다른 부분에서 수행되는 일과 일치하지 않으면 제대로 동작하지 않음
  - 논리를 위한 진실의 원천이 단 하나만 존재해야함

## 7.6.1 논리에 대한 진실의 원천이 여러 개 있으면 버그를 유발할 수 있다

- 각 값은 10진수 문자열 형식으로 변환된다
- 각 값의 문자열을 쉼표로 구분하여 결합한다
  
```java

class DataLogger {
    private final List<Integer> loggedValues;

    void saveValues(FileHandler file) {
        String serializedValues = loggedValues.map(value -> value.toString(Radix.BASE_10))
        .join(",");
        file.write(serializedValues);
    }

}

class DataLoader {
    List<Integer> loadValues(FileHandler file) {
        return file.readAsString()
        .split(",")
        .map(str -> Integer.parse(str, Radix.BASE_10));
    }
}

```

- 형식이 무엇인지에 대해 진실의 원천이 두 개 (DataLogger, DataLoader) 존재함
- 만약 수정사항이 발생했을 때, 한곳에만 바꾸면 문제가 발생할 수 있다.

## 7.6.2 해결책: 진실의 원천은 단 하나만 있어야 한다

- 직렬화 및 정수 형식은 하위 문제에 해당한다
- 이 부분을 하나의 클래스로 빼서 진실의 원천을 하나만 갖게 만든다.

```java

class IntListFormat {
    private static final String DELIMITER = ",";
    private static final Radix RADIX = Radix.BASE_10;

    String serialize(List<Integer> values) {
        return values
        .map(vlaue -> value.toString(RADIX))
        .join(DELIMITER);
    }

    List<Integer> deserialize(String serialized) {
        return serialized
        .split(DELIMITER)
        .map(str -> Integer.parse(str, RADIX));
    }
}

class DataLogger {
    private final List<Integer> loggedValues;
    private final IntListFormat intListFormat;

    void saveValues(FileHandler file) {
        file.write(intListFormat.serialize(loggedValues));
    }
}

class DataLoader {
    private final IntListFormat intListFormat;

    List<Integer> loadValues(FileHandler file) {
        return intListFormat.deserialize(file.readAsString());
    }
}

```

- 높은 수준 (값을 파일에 기록 / 읽기) 과 하위 문제 (IntListFormat) 을 분리하여 진실의 원천을 하나로 좁힘