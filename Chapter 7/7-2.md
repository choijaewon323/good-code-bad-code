# 7.2 객체를 깊은 수준까지 불변적으로 만드는 것을 고려하라

- 깊은 가변성 (Deep mutability) : 멤버 변수 자체가 가변적인 유형이고, 다른 코드가 멤버 변수에 액세스할 수 있는 경우

## 7.2.1 깊은 가변성은 오용을 초래할 수 있다

```java

class TextOptions {
    private final List<Font> fontFamily;
}

```

- fontFamily는 참조를 가지고 있으므로, 게터로 받은 뒤 수정이 가능하다.

## 7.2.2 해결책: 방어적으로 복사하라

```java

class TextOptions {
    private final List<Font> fontFamily;

    List<Font> getFontFamily() {
        return List.copyOf(fontFamily);
    }
}

```

- 단점
  - 복사 비용 증가
  - 클래스 내부에서는 여전히 fontFamily.add()를 호출할 수 있다.

## 7.2.3 해결책: 불변적 자료구조를 사용하라

- 처음부터 수정 불가능한 자료 구조를 사용하는 방법
- java : Guava 라이브러리의 ImmutableList 클래스
- 이걸 쓰면 방어적 복사가 필요없음