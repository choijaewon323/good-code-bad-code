# 8.4 클래스는 자신의 기능에만 집중해야 한다

- 요구 사항이 변경되면 변경과 관련된 코드만 수정되어야함 - 단일 개념이 단일 클래스 내에 완진히 포함되면 가능

## 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다

```java
class Chapter {
	TextBlock getPrelude() {}
	List<TextBlock> getSections() {}
}

class Book {
	private final List<Chapter> chapters;
	
	int wordCount() {
		return chapters
				.stream().map(Book::getChapterWorkCount)
				.sum();
	}
	
	private static int getChapterWorkCount(Chapter chapter) {
		return chapter.getPrelude().wordCount() + chapter.getSections()
				.map(section -> section.workCount())
				.sum();
	}
}
```

- getChapterWordCount 함수가 book 클래스에 두면 모듈화되지 않음
- 장에만 관련된 요구사항의 변경이 Book 클래스에도 영향을 미침

## 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들라
- getChapterWorkCount() 함수 내의 논리를 chapter 클래스로 옮기면 세부사항을 몰라도 된다

```java
class Chapter {
	TextBlock getPrelude() {}
	List<TextBlock> getSections() {}
	
	int wordCount() {
		return getPrelude().wordCount() + getSections()
				.stream().map(section -> section.wordCount())
				.sum();
	}
}

class Book {
	private final List<Chapter> chapters;

	int wordCount() {
		return chapters
				.stream().map(chapter -> chapter.wordCount())
				.sum();
	}
}
```
- 디미터의 법칙
  - 한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야한다
  - Chapter.getPrelude().wordCount() 이점을 위반
