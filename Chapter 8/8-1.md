# 8.1 의존성 주입의 사용을 고려하라

- 하위 문제에 대해 해결책이 하나만 존재하지는 않음
- 하위 문제를 재구성할 수 있는 방식으로 코드를 작성해야함
  - 의존성 주입

## 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다
```java
class RoutePlanner {
	private final RoadMap roadMap;
	
	RoutePlanner() {
		this.roadMap = new NorthAmericaRoadMap();
	}
}

interface RoadMap {
	List<Road> getRoads();
	List<Junction> getJunctions();
}

class NorthAmericaRoadMap implements RoadMap {}
```
- 특정 구현에 대한 의존성이 하드 코드로 되어있음 -> 다른 지역 여행에는 쓸모가 없다
- 만약 NorthAmericaRoadMap 생성에 다른 인자가 필요해지면? RoutePlanner에 또 추가해야함
```java
class RoutePlanner {
	private final RoadMap roadMap;

	RoutePlanner() {
		this.roadMap = new NorthAmericaRoadMap(
				USE_ONLINE_MAP, INCLUDE_SEASONAL_ROADS
		);
	}
}
```

## 8.1.2 해결책: 의존성 주입을 사용하라
```java
class RoutePlanner {
	private final RoadMap roadMap;

	RoutePlanner(RoadMap roadMap) {
		this.roadMap = roadMap;
	}
}

RoutePlanner europeRoutePlanner = new RoutePlanner(new EuropeRoadMap());

RoutePlanner northAmericaRoutePlanner = new RoutePlanner(new NorthAmericaRoadMap(true, false));
```

- 생성이 복잡하다면 팩토리 함수를 사용하면 된다.
```java
class RoutePlannerFactory {
	static RoutePlanner createEurope() {
		return new RoutePlanner(new EuropeRoadMap());
	}
	
	static RoutePlanner createDefaultNorthAmerica() {
		return new RoutePlanner(
				new NorthAmericaRoadMap(true, false)
		);
	}
}
```
- 팩토리 함수도 너무 많아진다면, 의존성 주입 프레임워크 사용
  
## 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라
- 만약 정적 함수에 의존한다면?
```java
class RoutePlanner {
	Route planRoute(LatLong startPoint, LatLong endPoint) {
		...
		List<Road> roads = NorthAmericaRoadMap.getRoads();
		List<Junction> roads = NorthAmericaRoadMap.getJunctions();
	}
}
```
- 나중에 바뀔 가능성이 있으므로 이를 분리하여 인스턴스 변수로 뽑아야함

