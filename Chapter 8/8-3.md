# 8.3 클래스 상속을 주의하라

- 진정한 is-a 관계를 가질때는 상속이 적절할 수 있다
- 많은 경우 상속 대신 구성을 상속 대신 사용할 수 있다

## 8.3.1 클래스 상속은 문제가 될 수 있다
```java
interface FileValueReader {
	String getNextValue();
	void close();
}
interface FileValueWriter {
	void writeValue(String value);
	void close();
}
class CsvFileHandler implements FileValueReader, FileValueWriter {
	public String getNextValue() {}
	
	public void close() {}
	
	public void writeValue(String value) {}
}
class IntFileReader extends CsvFileHandler {
	IntFileReader(File file) {
		super(file);
	}
	
	Integer getNextInt() {
		String nextValue = getNextValue();
		if (nextValue == null) {
			return null;
		}
		return Integer.parseInt(nextValue, Radix.BASE_10);
	}
}
```

- IntFileReader 인스턴스를 통해 getNextValue()와 같은 CsvFileHandler의 다른 함수 호출 가능 -> 문제가 됨

상속은 추상화 계층에 방해가 될 수 있다
- IntFileReader가 CsvFileHandler를 사용한다는 사실은 구현 세부사항이지만, 상속을 통해 의도치 않게 외부에 공개된다.

상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다
- 만약 세미콜론으로 구분된 값도 읽어야한다면? 새 클래스를 만들지만 IntFileReader 가 CsvFileHandler 대신 SemicolonFileHandler를 상속하도록 단순하게는 바꿀 수 없다
- 결국 또 새로운 IntFileReader 비슷한 걸 만들어서 세미콜론을 상속해야함

## 8.3.2 해결책: 구성을 사용하라

```java
class IntFileReader  {
	private final FileValueReader valueReader;

	public IntFileReader(FileValueReader valueReader) {
		this.valueReader = valueReader;
	}
	
	Integer getNextInt() {
		String nextValue = valueReader.getNextValue();
		if (nextValue == null) {
			return null;
		}
		return Integer.parseInt(nextValue);
	}
	
	void close() {
		valueReader.close();
	}
}
```
- CsvFileReader 클래스의 기능이 더이상 외부로 노출되지 않음
- 만약 세미콜론 구분 값도 지원해야한다면, SemicolonFileHander를 주입해주면 됨

## 8.3.3 진정한 is-a 관계는 어떤가?
- 진정한 is-a 관계여도 상속이 좋다고 보기 어렵다
- 취약한 베이스 클래스 문제
  - 슈퍼클래스 수정 시 서브 클래스에도 문제가 발생할 수 있음
- 다이아몬드 문제
  - 어떤 슈퍼클래스로부터 상속해야하는지 모호할 수 있음
- 문제가 있는 계층 구조
  - 단일 상속만 가능한 경우 문제 발생
- 인터페이스 및 구성을 가급적이면 사용하자

